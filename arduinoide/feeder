#include <ESP8266WiFi.h>

/*  ------  pacotes MQTT at√© 1 024 B ------  */
#define MQTT_MAX_PACKET_SIZE 1024
#include <PubSubClient.h>
/*  --------------------------------------- */

#include <LittleFS.h>
#include <ArduinoJson.h>
#include <time.h>
#include <BearSSLHelpers.h>

/* ---------- Rede ---------- */
const char* ssid     = "OsMarotos";
const char* password = "CASA1234@";

/* ---------- MQTT ---------- */
const char* mqtt_broker   = "ha86020d.ala.eu-central-1.emqxsl.com";
const int   mqtt_port     = 8883;
const char* mqtt_topic    = "petfeeder/command";
const char* mqtt_username = "mrhormigo";
const char* mqtt_password = "Hormigo23888";

/* ---------- NTP ---------- */
const char* ntp_server = "pool.ntp.org";

/* ---------- Pinos do A4988 ---------- */
#define STEP_PIN 14
#define DIR_PIN  16
#define EN_PIN   12

/* ---------- Estrutura ---------- */
struct Schedule {
  int   hour=-1, minute=-1, steps=200, speed=800;
  int   antiSteps=0;
  float antiRatio=0.0;
  bool  reverse=false;
};

Schedule schedules[4];
int   scheduledCount   = 0;
bool  scheduleSuspended= false;
time_t lastTrigger     = 0;

/* ---------- CA encurtada ---------- */
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGh...
-----END CERTIFICATE-----
)EOF";

/* ---------- MQTT ---------- */
BearSSL::WiFiClientSecure secureClient;
PubSubClient mqtt_client(secureClient);

/* ---------- Motor avan√ßado (blocos anti-clog) ---------- */
void runMotorAdvanced(int steps,int speed,bool revMain,
                      int antiSteps,float antiRatio)
{
  randomSeed(micros());

  /* 1) pr√©-pulso inverso */
  if(antiSteps>0){
    digitalWrite(DIR_PIN, revMain ? LOW : HIGH);   // sentido oposto
    digitalWrite(EN_PIN, LOW);
    for(int i=0;i<antiSteps;i++){
      digitalWrite(STEP_PIN, HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN, LOW ); delayMicroseconds(speed);
    }
  }

  /* 2) rota√ß√£o principal em blocos */
  long totalInv  = (long)(steps * antiRatio);
  if(antiSteps==0 || antiRatio<=0) totalInv = 0;
  long blocks    = (antiSteps>0) ? totalInv / antiSteps : 0;
  long fwdChunks = blocks + 1;
  long fwdPerChunk = (blocks==0) ? steps : (steps-totalInv)/fwdChunks;

  long done = 0;
  digitalWrite(EN_PIN, LOW);

  for(long b=0; b<fwdChunks; b++){

    /* bloco hor√°rio */
    digitalWrite(DIR_PIN, revMain ? HIGH : LOW);
    for(long i=0;i<fwdPerChunk && done<steps;i++,done++){
      digitalWrite(STEP_PIN,HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN,LOW ); delayMicroseconds(speed);
      if(done%1000==0) yield();          // alimenta watchdog
    }

    /* bloco inverso */
    if(b<blocks){
      digitalWrite(DIR_PIN, revMain ? LOW : HIGH);
      for(int j=0;j<antiSteps;j++,done++){
        digitalWrite(STEP_PIN,HIGH); delayMicroseconds(speed);
        digitalWrite(STEP_PIN,LOW ); delayMicroseconds(speed);
        if(done%1000==0) yield();
      }
    }
  }

  digitalWrite(EN_PIN, HIGH);
  Serial.println("‚úÖ Motor terminou (anti-clog blocos)");
}

/* ---------- Persist√™ncia ---------- */
void saveAllSchedules(){
  File f = LittleFS.open("/schedules.json","w");
  if(!f){ Serial.println("‚ùå Falha a guardar"); return; }

  DynamicJsonDocument doc(1024);
  JsonArray arr = doc.createNestedArray("schedules");
  for(int i=0;i<scheduledCount;i++){
    JsonObject o = arr.createNestedObject();
    o["hour"]=schedules[i].hour;     o["minute"]=schedules[i].minute;
    o["steps"]=schedules[i].steps;   o["speed"]=schedules[i].speed;
    o["antiSteps"]=schedules[i].antiSteps;
    o["antiRatio"]=schedules[i].antiRatio;
    o["reverse"]=schedules[i].reverse;
  }
  serializeJson(doc,f); f.close();
  Serial.println("‚úÖ guardado");
}

void loadAllSchedules(){
  if(!LittleFS.exists("/schedules.json")) return;
  File f = LittleFS.open("/schedules.json","r");
  if(!f) return;

  DynamicJsonDocument doc(1024);
  if(deserializeJson(doc,f)){ Serial.println("JSON inv√°lido"); return; }

  JsonArray arr = doc["schedules"]; scheduledCount = 0;
  for(JsonObject o: arr){
    if(scheduledCount>=4) break;
    Schedule &s = schedules[scheduledCount++];
    s.hour=o["hour"];         s.minute=o["minute"];
    s.steps=o["steps"];       s.speed=o["speed"];
    s.antiSteps=o["antiSteps"]|0;
    s.antiRatio=o["antiRatio"]|0.0;
    s.reverse  =o["reverse"]  |false;

    Serial.printf("üìÇ Carregado %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                  s.hour,s.minute,s.steps,s.antiSteps,s.antiRatio,s.reverse);
  }
  f.close();
}

/* ---------- MQTT callback ---------- */
void mqttCallback(char* topic,byte* payload,unsigned len){
  String msg; for(unsigned i=0;i<len;i++) msg+=(char)payload[i];

  DynamicJsonDocument doc(1024);
  DeserializationError err = deserializeJson(doc,msg);
  if(err){
    if(msg=="feed") runMotorAdvanced(200,800,false,0,0);
    else            Serial.println(err.c_str());
    return;
  }

  /* feed instant√¢neo */
  if(doc["command"]=="feed"){
    runMotorAdvanced(
      doc["steps"]|200,
      doc["speed"]|800,
      doc["reverse"]|false,
      doc["anticlog_steps"]|0,
      doc["anticlog_ratio"]|0.0
    );
  }

  /* suspender / retomar */
  if(doc["suspend"]==true){  scheduleSuspended=true;  Serial.println("‚è∏Ô∏è pausado"); }
  if(doc["resume"] ==true){  scheduleSuspended=false; Serial.println("‚ñ∂Ô∏è retomado"); }

  /* novos agendamentos */
  if(doc.containsKey("schedules")){
    JsonArray arr = doc["schedules"]; scheduledCount = 0;
    for(JsonObject o: arr){
      if(scheduledCount>=4) break;
      Schedule &s=schedules[scheduledCount++];
      s.hour=o["hour"];       s.minute=o["minute"];
      s.steps=o["steps"];     s.speed=o["speed"];
      s.antiSteps=o["anticlog_steps"]|0;
      s.antiRatio=o["anticlog_ratio"]|0.0;
      s.reverse  =o["reverse"]|false;

      Serial.printf("üóìÔ∏è %d) %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    scheduledCount,s.hour,s.minute,s.steps,
                    s.antiSteps,s.antiRatio,s.reverse);
    }
    saveAllSchedules();
  }
}

/* ---------- Conectividade ---------- */
void connectWiFi(){
  Serial.print("üîå [WiFi] A ligar");
  WiFi.begin(ssid,password);
  while(WiFi.status()!=WL_CONNECTED){delay(500);Serial.print(".");}
  Serial.println("\n‚úÖ [WiFi] Ligado");
}
void syncTime(){
  Serial.print("‚è∞ [NTP] A sincronizar");
  configTime(0,0,ntp_server);
  setenv("TZ","WET-0WEST,M3.5.0/1,M10.5.0/2",1); tzset();
  while(time(nullptr)<100000){delay(500);Serial.print(".");}
  Serial.println("\n‚úÖ [NTP] Hora sincronizada");
}
void connectMQTT(){
  BearSSL::X509List cert(ca_cert); secureClient.setTrustAnchors(&cert);
  mqtt_client.setServer(mqtt_broker,mqtt_port);
  mqtt_client.setCallback(mqttCallback);
  while(!mqtt_client.connected()){
    if(mqtt_client.connect(("petfeeder-"+String(ESP.getChipId())).c_str(),
        mqtt_username,mqtt_password)){
      Serial.println("‚úÖ [MQTT] Ligado");
      mqtt_client.subscribe(mqtt_topic);
    }else{
      Serial.printf("‚ùå [MQTT] %d\n",mqtt_client.state());
      delay(3000);
    }
  }
}

/* ---------- Setup ---------- */
void setup(){
  Serial.begin(115200);
  pinMode(STEP_PIN,OUTPUT); pinMode(DIR_PIN,OUTPUT); pinMode(EN_PIN,OUTPUT);
  digitalWrite(EN_PIN,HIGH);

  LittleFS.begin();
  connectWiFi();
  syncTime();

  mqtt_client.setBufferSize(1024);   // buffer maior
  connectMQTT();

  loadAllSchedules();
}

/* ---------- Loop ---------- */
void loop(){
  if(!mqtt_client.connected()) connectMQTT();
  mqtt_client.loop();
  if(scheduleSuspended) return;

  time_t now=time(nullptr); struct tm* t=localtime(&now);

  for(int i=0;i<scheduledCount;i++){
    Schedule &s=schedules[i];
    if(s.hour==t->tm_hour && s.minute==t->tm_min && abs(now-lastTrigger)>60){
      Serial.printf("üöÄ Executar %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    s.hour,s.minute,s.steps,s.antiSteps,s.antiRatio,s.reverse);
      runMotorAdvanced(s.steps,s.speed,s.reverse,s.antiSteps,s.antiRatio);
      lastTrigger = now;
    }
  }
}
