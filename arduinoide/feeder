/* =========================================================
   Pet Feeder ESP8266 ‚Äì FW_VERSION + WiFi fallback + triple-tap reset
   ========================================================= */
#include <ESP8266WiFi.h>
#include <WiFiManager.h>        // portal cativo
#include <Ticker.h>             // piscar LED

#define MQTT_MAX_PACKET_SIZE 1024
#include <PubSubClient.h>

#include <LittleFS.h>
#include <ArduinoJson.h>
#include <time.h>
#include <BearSSLHelpers.h>

/* ---------- VERS√ÉO DO FIRMWARE ---------- */
#define FW_VERSION 1

/* ---------- Pinos ---------- */
#define LED_PIN   13      // D7 ‚Äì LED externo (HIGH aceso)
#define BTN_PIN    5      // D1 ‚Äì TTP223 activo-LOW
#define STEP_PIN  14
#define DIR_PIN   16
#define EN_PIN    12

/* ---------- Triple-tap ---------- */
#define REQUIRED_TAPS  3
#define TAP_WINDOW_MS  10000

/* ---------- MQTT ---------- */
const char* mqtt_broker   = "ha86020d.ala.eu-central-1.emqxsl.com";
const int   mqtt_port     = 8883;
const char* mqtt_topic    = "petfeeder/command";
const char* mqtt_username = "mrhormigo";
const char* mqtt_password = "Hormigo23888";

/* ---------- NTP ---------- */
const char* ntp_server = "pool.ntp.org";

/* ---------- LED piscar ---------- */
Ticker ledTicker;
void toggleLED(){ digitalWrite(LED_PIN,!digitalRead(LED_PIN)); }
void startBlink(){ pinMode(LED_PIN,OUTPUT); digitalWrite(LED_PIN,LOW);
                   ledTicker.attach(0.5,toggleLED); }
void stopBlink(){  ledTicker.detach(); digitalWrite(LED_PIN,LOW); }

/* ---------- Triple-tap vars ---------- */
volatile uint8_t  tapCount   = 0;
volatile unsigned long firstTap = 0;
volatile bool resetFlag = false;

ICACHE_RAM_ATTR void tapISR(){
  if(digitalRead(BTN_PIN)==LOW){
    unsigned long now=millis();
    if(tapCount==0 || (now-firstTap)>TAP_WINDOW_MS){
      tapCount=1; firstTap=now;
    }else if(++tapCount>=REQUIRED_TAPS){
      resetFlag=true; tapCount=0;
    }
  }
}
void executeReset(){
  Serial.println("üõ†Ô∏è  Triple-tap ‚Äì reset total");
  WiFiManager wm; wm.resetSettings();            // limpa Wi-Fi
  if(LittleFS.exists("/schedules.json"))
      LittleFS.remove("/schedules.json");        // limpa hor√°rios
  delay(300);
  ESP.restart();
}

/* ---------- Estrutura de hor√°rios ---------- */
struct Schedule{
  int   hour=-1, minute=-1;
  int   steps=200, speed=800;
  int   antiSteps=0; float antiRatio=0.0;
  bool  reverse=false;
};
Schedule schedules[4]; int scheduledCount=0;
bool scheduleSuspended=false; time_t lastTrigger=0;

/* ---------- Certificado CA (encurtado) ---------- */
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
-----END CERTIFICATE-----
)EOF";

/* ---------- Inst√¢ncias MQTT ---------- */
BearSSL::WiFiClientSecure secureClient;
PubSubClient mqtt_client(secureClient);

/* ---------- Motor com anti-clog (original) ---------- */
void runMotorAdvanced(int steps,int speed,bool revMain,
                      int antiSteps,float antiRatio){
  randomSeed(micros());

  /* 1. pr√©-pulso inverso */
  if(antiSteps>0){
    digitalWrite(DIR_PIN,revMain?LOW:HIGH);
    digitalWrite(EN_PIN,LOW);
    for(int i=0;i<antiSteps;i++){
      digitalWrite(STEP_PIN,HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN,LOW ); delayMicroseconds(speed);
    }
  }

  /* 2. rota√ß√£o principal em blocos */
  long totalInv=(long)(steps*antiRatio);
  if(antiSteps==0||antiRatio<=0) totalInv=0;
  long blocks=(antiSteps>0)?totalInv/antiSteps:0;
  long fwdChunks=blocks+1;
  long fwdPerChunk=(blocks==0)?steps:(steps-totalInv)/fwdChunks;

  long done=0; digitalWrite(EN_PIN,LOW);

  for(long b=0;b<fwdChunks;b++){
    /* bloco hor√°rio */
    digitalWrite(DIR_PIN,revMain?HIGH:LOW);
    for(long i=0;i<fwdPerChunk && done<steps;i++,done++){
      digitalWrite(STEP_PIN,HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN,LOW ); delayMicroseconds(speed);
      if(done%1000==0) yield();
    }
    /* bloco inverso */
    if(b<blocks){
      digitalWrite(DIR_PIN,revMain?LOW:HIGH);
      for(int j=0;j<antiSteps;j++,done++){
        digitalWrite(STEP_PIN,HIGH); delayMicroseconds(speed);
        digitalWrite(STEP_PIN,LOW ); delayMicroseconds(speed);
        if(done%1000==0) yield();
      }
    }
  }
  digitalWrite(EN_PIN,HIGH);
  Serial.println("‚úÖ Motor terminou (anti-clog)");
}

/* ---------- Guardar hor√°rios (original) ---------- */
void saveAllSchedules(){
  File f=LittleFS.open("/schedules.json","w");
  if(!f){ Serial.println("‚ùå Falha a guardar"); return; }

  DynamicJsonDocument doc(1024);
  doc["fw_version"]=FW_VERSION;
  JsonArray arr=doc.createNestedArray("schedules");
  for(int i=0;i<scheduledCount;i++){
    JsonObject o=arr.createNestedObject();
    o["hour"]=schedules[i].hour;
    o["minute"]=schedules[i].minute;
    o["steps"]=schedules[i].steps;
    o["speed"]=schedules[i].speed;
    o["antiSteps"]=schedules[i].antiSteps;
    o["antiRatio"]=schedules[i].antiRatio;
    o["reverse"]=schedules[i].reverse;
  }
  serializeJson(doc,f); f.close();
  Serial.println("‚úÖ Agendamentos guardados");
}

/* ---------- Carregar hor√°rios (original) ---------- */
void loadAllSchedules(){
  if(!LittleFS.exists("/schedules.json")) return;
  File f=LittleFS.open("/schedules.json","r"); if(!f) return;

  DynamicJsonDocument doc(1024);
  if(deserializeJson(doc,f)){ Serial.println("JSON inv√°lido"); return; }

  if(doc["fw_version"]!=FW_VERSION){
    Serial.println("‚ö†Ô∏è Vers√£o diferente ‚Äì regras antigas removidas");
    LittleFS.remove("/schedules.json");
    scheduledCount=0; return;
  }

  JsonArray arr=doc["schedules"]; scheduledCount=0;
  for(JsonObject o:arr){
    if(scheduledCount>=4) break;
    Schedule &s=schedules[scheduledCount++];
    s.hour=o["hour"];     s.minute=o["minute"];
    s.steps=o["steps"];   s.speed=o["speed"];
    s.antiSteps=o["antiSteps"]|0;
    s.antiRatio=o["antiRatio"]|0.0;
    s.reverse=o["reverse"]|false;
    Serial.printf("üìÇ %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                  s.hour,s.minute,s.steps,s.antiSteps,s.antiRatio,s.reverse);
  }
  f.close();
}

/* ---------- MQTT callback (original) ---------- */
void mqttCallback(char* topic,byte* payload,unsigned len){
  String msg; for(unsigned i=0;i<len;i++) msg+=(char)payload[i];

  DynamicJsonDocument doc(1024);
  if(deserializeJson(doc,msg)){           // simples texto
    if(msg=="feed") runMotorAdvanced(200,800,false,0,0);
    return;
  }

  /* feed instant√¢neo */
  if(doc["command"]=="feed"){
    runMotorAdvanced(doc["steps"]|200,
                     doc["speed"]|800,
                     doc["reverse"]|false,
                     doc["anticlog_steps"]|0,
                     doc["anticlog_ratio"]|0.0);
  }

  /* suspender / retomar */
  if(doc.containsKey("suspend")){
    scheduleSuspended=doc["suspend"];
    Serial.println(scheduleSuspended? "‚è∏Ô∏è Suspenso":"‚ñ∂Ô∏è Retomado");
  }

  /* novos agendamentos */
  if(doc.containsKey("schedules")){
    JsonArray arr=doc["schedules"]; scheduledCount=0;
    for(JsonObject o:arr){
      if(scheduledCount>=4) break;
      Schedule &s=schedules[scheduledCount++];
      s.hour=o["hour"];     s.minute=o["minute"];
      s.steps=o["steps"];   s.speed=o["speed"];
      s.antiSteps=o["anticlog_steps"]|0;
      s.antiRatio=o["anticlog_ratio"]|0.0;
      s.reverse=o["reverse"]|false;
      Serial.printf("üóìÔ∏è %d) %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    scheduledCount,s.hour,s.minute,s.steps,
                    s.antiSteps,s.antiRatio,s.reverse);
    }
    saveAllSchedules();
  }
}

/* ---------- Wi-Fi (WiFiManager) ---------- */
void connectWiFi(){
  Serial.println("üîå [WiFi] A ligar‚Ä¶"); startBlink();
  WiFiManager wm; wm.setConnectTimeout(30); wm.setConfigPortalTimeout(180);
  if(wm.autoConnect("PetFeeder-Setup","12345678")){
    stopBlink();
    Serial.printf("‚úÖ [WiFi] Ligado a %s  üì∂ IP %s\n",
                  WiFi.SSID().c_str(),WiFi.localIP().toString().c_str());
  }else{
    Serial.println("‚ö†Ô∏è  Portal aberto ‚Äì configure Wi-Fi");
  }
}

/* ---------- Hora & MQTT ---------- */
void syncTime(){
  Serial.print("‚è∞ [NTP] A sincronizar");
  configTime(0,0,ntp_server);
  setenv("TZ","WET-0WEST,M3.5.0/1,M10.5.0/2",1); tzset();
  while(time(nullptr)<100000){ delay(500); Serial.print("."); }
  Serial.println("\n‚úÖ [NTP] Hora sincronizada");
}
void connectMQTT(){
  BearSSL::X509List cert(ca_cert); secureClient.setTrustAnchors(&cert);
  mqtt_client.setServer(mqtt_broker,mqtt_port);
  mqtt_client.setCallback(mqttCallback);
  while(!mqtt_client.connected()){
    if(mqtt_client.connect(("petfeeder-"+String(ESP.getChipId())).c_str(),
                           mqtt_username,mqtt_password)){
      Serial.println("‚úÖ [MQTT] Ligado");
      mqtt_client.subscribe(mqtt_topic);
    }else{
      Serial.printf("‚ùå [MQTT] %d\n", mqtt_client.state());
      delay(3000);
    }
  }
}

/* ---------- Setup ---------- */
void setup(){
  Serial.begin(115200);
  pinMode(STEP_PIN,OUTPUT); pinMode(DIR_PIN,OUTPUT);
  pinMode(EN_PIN, OUTPUT);  digitalWrite(EN_PIN,HIGH);

  pinMode(BTN_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BTN_PIN), tapISR, FALLING);

  LittleFS.begin();
  connectWiFi();
  syncTime();
  mqtt_client.setBufferSize(1024);
  connectMQTT();
  loadAllSchedules();
}

/* ---------- Loop ---------- */
void loop(){
  if(!mqtt_client.connected()) connectMQTT();
  mqtt_client.loop();
  if(scheduleSuspended) return;

  time_t now=time(nullptr); struct tm* t=localtime(&now);
  for(int i=0;i<scheduledCount;i++){
    Schedule &s=schedules[i];
    if(s.hour==t->tm_hour && s.minute==t->tm_min &&
       abs(now-lastTrigger)>60){
      Serial.printf("üöÄ Executar %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    s.hour,s.minute,s.steps,s.antiSteps,s.antiRatio,s.reverse);
      runMotorAdvanced(s.steps,s.speed,s.reverse,
                       s.antiSteps,s.antiRatio);
      lastTrigger=now;
    }
  }

  if(resetFlag){ noInterrupts(); resetFlag=false; interrupts();
                 executeReset(); }
}
