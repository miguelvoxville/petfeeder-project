#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <LittleFS.h>
#include <ArduinoJson.h>
#include <time.h>
#include <BearSSLHelpers.h>

// WiFi
const char* ssid = "OsMarotos";
const char* password = "CASA1234@";

// MQTT
const char* mqtt_broker = "ha86020d.ala.eu-central-1.emqxsl.com";
const int mqtt_port = 8883;
const char* mqtt_topic = "petfeeder/command";
const char* mqtt_username = "mrhormigo";
const char* mqtt_password = "Hormigo23888";

// NTP
const char* ntp_server = "pool.ntp.org";
const long gmt_offset_sec = 0;
const int daylight_offset_sec = 0;

// Pinos do motor
#define STEP_PIN 14
#define DIR_PIN  16
#define EN_PIN   12

// MQTT & SSL
BearSSL::WiFiClientSecure secureClient;
PubSubClient mqtt_client(secureClient);

// Certificado CA
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
-----END CERTIFICATE-----
)EOF";

// Estrutura do agendamento
struct Schedule {
  int hour = -1;
  int minute = -1;
  int steps = 200;
  int speed = 800;
} currentSchedule;

time_t lastTrigger = 0;

// FunÃ§Ã£o para correr o motor
void runMotor(int steps, int speed) {
  Serial.println("ðŸšš A rodar motor...");
  digitalWrite(EN_PIN, LOW);
  digitalWrite(DIR_PIN, HIGH);

  for (int i = 0; i < steps; i++) {
    digitalWrite(STEP_PIN, HIGH);
    delayMicroseconds(speed);
    digitalWrite(STEP_PIN, LOW);
    delayMicroseconds(speed);
  }

  digitalWrite(EN_PIN, HIGH);
  Serial.println("âœ… Motor terminou de rodar.");
}

// Guardar agendamento
void saveSchedule() {
  File f = LittleFS.open("/schedule.json", "w");
  if (!f) {
    Serial.println("âŒ Erro a guardar agendamento.");
    return;
  }

  StaticJsonDocument<256> doc;
  doc["hour"] = currentSchedule.hour;
  doc["minute"] = currentSchedule.minute;
  doc["steps"] = currentSchedule.steps;
  doc["speed"] = currentSchedule.speed;
  serializeJson(doc, f);
  f.close();
  Serial.println("âœ… Agendamento guardado");
}

// Carregar agendamento
void loadSchedule() {
  if (!LittleFS.exists("/schedule.json")) return;

  File f = LittleFS.open("/schedule.json", "r");
  if (!f) return;

  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, f);
  if (!err) {
    currentSchedule.hour = doc["hour"];
    currentSchedule.minute = doc["minute"];
    currentSchedule.steps = doc["steps"];
    currentSchedule.speed = doc["speed"];
    Serial.println("âœ… Agendamento carregado da memÃ³ria");
  }
  f.close();
}

// MQTT callback
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String msg;
  for (int i = 0; i < length; i++) msg += (char)payload[i];
  msg.trim();

  Serial.print("[MQTT] Mensagem recebida: ");
  Serial.println(msg);

  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, msg);

  if (!err) {
    if (doc.containsKey("hour") && doc.containsKey("minute")) {
      currentSchedule.hour = doc["hour"];
      currentSchedule.minute = doc["minute"];
      currentSchedule.steps = doc["steps"] | 200;
      currentSchedule.speed = doc["speed"] | 800;
      saveSchedule();
    } else if (doc["command"] == "feed") {
      int steps = doc["steps"] | currentSchedule.steps;
      int speed = doc["speed"] | currentSchedule.speed;
      runMotor(steps, speed);
    }
  } else if (msg == "feed") {
    runMotor(currentSchedule.steps, currentSchedule.speed);
  }
}

// Conectar WiFi
void connectWiFi() {
  WiFi.begin(ssid, password);
  Serial.print("ðŸ”Œ [WiFi] A ligar...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.println("âœ… [WiFi] Ligado");
  Serial.print("ðŸ“¡ IP: ");
  Serial.println(WiFi.localIP());
}

// Sincronizar hora com timezone PT + DST
void syncTime() {
  configTime(gmt_offset_sec, daylight_offset_sec, ntp_server);
  setenv("TZ", "WET-0WEST,M3.5.0/1,M10.5.0/2", 1);  // Portugal com horÃ¡rio de verÃ£o
  tzset();

  while (time(nullptr) < 100000) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.println("â° [NTP] Hora sincronizada");
}

// Conectar MQTT
void connectMQTT() {
  BearSSL::X509List cert(ca_cert);
  secureClient.setTrustAnchors(&cert);
  mqtt_client.setServer(mqtt_broker, mqtt_port);
  mqtt_client.setCallback(mqttCallback);

  while (!mqtt_client.connected()) {
    String clientId = "petfeeder-" + String(ESP.getChipId());
    Serial.println("ðŸ” [MQTT] A ligar ao broker...");
    if (mqtt_client.connect(clientId.c_str(), mqtt_username, mqtt_password)) {
      Serial.println("âœ… [MQTT] Ligado ao broker");
      mqtt_client.subscribe(mqtt_topic);
    } else {
      Serial.print("âŒ [MQTT] Erro: ");
      Serial.print(mqtt_client.state());
      Serial.println(" (a tentar em 5s)");
      delay(5000);
    }
  }
}

// Setup
void setup() {
  Serial.begin(115200);
  pinMode(STEP_PIN, OUTPUT);
  pinMode(DIR_PIN, OUTPUT);
  pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, HIGH);

  LittleFS.begin();
  connectWiFi();
  syncTime();
  connectMQTT();
  loadSchedule();
}

// Loop
void loop() {
  if (!mqtt_client.connected()) connectMQTT();
  mqtt_client.loop();

  time_t now = time(nullptr);
  struct tm* t = localtime(&now);

  if (currentSchedule.hour == t->tm_hour &&
      currentSchedule.minute == t->tm_min &&
      abs(now - lastTrigger) > 60) {
    runMotor(currentSchedule.steps, currentSchedule.speed);
    lastTrigger = now;
  }
}
