/* =========================================================
   Pet Feeder ESP8266  ‚Äì  FW_VERSION + WiFi fallback
   + reset 10-tap  + dispensa manual  + LED de estado
   ========================================================= */
#include <ESP8266WiFi.h>
#include <WiFiManager.h>
#include <Ticker.h>

#define MQTT_MAX_PACKET_SIZE 1024
#include <PubSubClient.h>

#include <LittleFS.h>
#include <ArduinoJson.h>
#include <time.h>
#include <BearSSLHelpers.h>

/* ---------- VERS√ÉO DO FIRMWARE ---------- */
#define FW_VERSION 1

/* ---------- Pinos ---------- */
#define LED_PIN   13        // D7 ‚Äì suporta PWM
#define BTN_PIN    5        // D1 ‚Äì TTP223 (LOW activo)
#define STEP_PIN  14
#define DIR_PIN   16
#define EN_PIN    12

/* ---------- Reset 10-tap ---------- */
#define REQUIRED_TAPS  10
#define TAP_WINDOW_MS  15000   // 15 s

/* ---------- MQTT ---------- */
const char* mqtt_broker   = "ha86020d.ala.eu-central-1.emqxsl.com";
const int   mqtt_port     = 8883;
const char* mqtt_topic    = "petfeeder/command";
const char* mqtt_username = "mrhormigo";
const char* mqtt_password = "Hormigo23888";

/* ---------- NTP ---------- */
const char* ntp_server = "pool.ntp.org";

/* ---------- LED ‚Äì estados ---------- */
Ticker blinkTicker, breathTicker;
bool  ledBlinking = false, ledBreathing = false;
int   breathVal = 0, breathDir = 18;

void toggleLED() { digitalWrite(LED_PIN, !digitalRead(LED_PIN)); }
void breathStep() {
  analogWrite(LED_PIN, breathVal);
  breathVal += breathDir;
  if (breathVal >= 1023 || breathVal <= 0) breathDir = -breathDir;
}
void startBlink() {
  pinMode(LED_PIN, OUTPUT);
  breathTicker.detach(); blinkTicker.detach();
  digitalWrite(LED_PIN, LOW);
  blinkTicker.attach(0.5, toggleLED);
  ledBlinking = true;  ledBreathing = false;
}
void stopBlink()  {
  blinkTicker.detach();
  digitalWrite(LED_PIN, HIGH);
  ledBlinking = false;
}
void startBreath() {
  pinMode(LED_PIN, OUTPUT);
  blinkTicker.detach(); breathTicker.detach();
  breathVal = 0; breathDir = 18;
  breathTicker.attach_ms(30, breathStep);
  ledBreathing = true;  ledBlinking = false;
}
void stopBreath() {
  breathTicker.detach();
  analogWrite(LED_PIN, 1023);
  ledBreathing = false;
}

/* ---------- Dispensa manual ---------- */
#define MANUAL_STEP_MS  1      // 1 ms ‚Üí 500 passos/s

Ticker manualTicker;
bool manualFeedActive = false;

void stepPulse() {
  digitalWrite(STEP_PIN, HIGH);
  delayMicroseconds(4);        // largura m√≠nima de pulso
  digitalWrite(STEP_PIN, LOW);
}
void startManualFeed() {
  Serial.println("üñêÔ∏è  Dispensa manual ON");
  digitalWrite(DIR_PIN, LOW);  // troca para HIGH se precisares sentido inverso
  digitalWrite(EN_PIN, LOW);
  manualTicker.attach_ms(MANUAL_STEP_MS, stepPulse);
  manualFeedActive = true;
}
void stopManualFeed() {
  manualTicker.detach();
  digitalWrite(EN_PIN, HIGH);
  manualFeedActive = false;
  Serial.println("üñêÔ∏è  Dispensa manual OFF");
}

/* ---------- Estrutura de hor√°rios ---------- */
struct Schedule {
  int   hour = -1, minute = -1;
  int   steps = 200, speed = 800;
  int   antiSteps = 0;  float antiRatio = 0.0;
  bool  reverse = false;
};
Schedule schedules[4];  int scheduledCount = 0;
bool   scheduleSuspended = false;
time_t lastTrigger = 0;

/* ---------- Certificado CA ---------- */
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
-----END CERTIFICATE-----
)EOF";

/* ---------- Inst√¢ncias ---------- */
BearSSL::WiFiClientSecure secureClient;
PubSubClient mqtt_client(secureClient);

/* ---------- Motor com anti-clog ---------- */
void runMotorAdvanced(int steps,int speed,bool revMain,
                      int antiSteps,float antiRatio) {
  randomSeed(micros());

  /* pr√©-pulso inverso */
  if (antiSteps > 0) {
    digitalWrite(DIR_PIN, revMain ? LOW : HIGH);
    digitalWrite(EN_PIN, LOW);
    for (int i = 0; i < antiSteps; i++) {
      digitalWrite(STEP_PIN, HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN, LOW ); delayMicroseconds(speed);
    }
  }

  /* rota√ß√£o principal em blocos */
  long totalInv = (long)(steps * antiRatio);
  if (antiSteps == 0 || antiRatio <= 0) totalInv = 0;
  long blocks   = (antiSteps > 0) ? totalInv / antiSteps : 0;
  long chunks   = blocks + 1;
  long fwdChunk = (blocks == 0) ? steps : (steps - totalInv) / chunks;

  long done = 0;  digitalWrite(EN_PIN, LOW);

  for (long b = 0; b < chunks; b++) {
    digitalWrite(DIR_PIN, revMain ? HIGH : LOW);
    for (long i = 0; i < fwdChunk && done < steps; i++, done++) {
      digitalWrite(STEP_PIN, HIGH); delayMicroseconds(speed);
      digitalWrite(STEP_PIN, LOW ); delayMicroseconds(speed);
      if (done % 1000 == 0) yield();
    }
    if (b < blocks) {                       // bloco inverso
      digitalWrite(DIR_PIN, revMain ? LOW : HIGH);
      for (int j = 0; j < antiSteps; j++, done++) {
        digitalWrite(STEP_PIN, HIGH); delayMicroseconds(speed);
        digitalWrite(STEP_PIN, LOW ); delayMicroseconds(speed);
        if (done % 1000 == 0) yield();
      }
    }
  }
  digitalWrite(EN_PIN, HIGH);
  Serial.println("‚úÖ  Motor terminou");
}

/* ---------- Reset 10-tap ---------- */
volatile uint8_t  tapCount   = 0;
volatile unsigned long firstTap = 0;
volatile bool resetFlag = false;

ICACHE_RAM_ATTR void tapISR() {
  if (digitalRead(BTN_PIN) == HIGH) {
    unsigned long now = millis();
    if (tapCount == 0 || (now - firstTap) > TAP_WINDOW_MS) {
      tapCount = 1;  firstTap = now;
    } else if (++tapCount >= REQUIRED_TAPS) {
      resetFlag = true;  tapCount = 0;
    }
  }
}
void executeReset() {
  Serial.println("üõ†Ô∏è  Reset total");
  WiFiManager wm;  wm.resetSettings();
  if (LittleFS.exists("/schedules.json")) LittleFS.remove("/schedules.json");
  delay(300);  ESP.restart();
}

/* ---------- Persist√™ncia ---------- */
void saveAllSchedules() {
  File f = LittleFS.open("/schedules.json", "w");
  if (!f) { Serial.println("‚ùå Falha a guardar"); return; }

  DynamicJsonDocument doc(1152);
  doc["fw_version"] = FW_VERSION;
  doc["suspend"]    = scheduleSuspended;
  JsonArray arr = doc.createNestedArray("schedules");
  for (int i = 0; i < scheduledCount; i++) {
    JsonObject o = arr.createNestedObject();
    o["hour"]      = schedules[i].hour;
    o["minute"]    = schedules[i].minute;
    o["steps"]     = schedules[i].steps;
    o["speed"]     = schedules[i].speed;
    o["antiSteps"] = schedules[i].antiSteps;
    o["antiRatio"] = schedules[i].antiRatio;
    o["reverse"]   = schedules[i].reverse;
  }
  serializeJson(doc, f);  f.close();
  Serial.println("üíæ  Hor√°rios gravados");
}

void loadAllSchedules() {
  if (!LittleFS.exists("/schedules.json")) return;
  File f = LittleFS.open("/schedules.json", "r");  if (!f) return;

  DynamicJsonDocument doc(1152);
  if (deserializeJson(doc, f)) { Serial.println("JSON inv√°lido"); return; }

  if (doc["fw_version"] != FW_VERSION) {
    Serial.println("‚ö†Ô∏è  Vers√£o diferente ‚Äì ficheiro removido");
    LittleFS.remove("/schedules.json");  return;
  }

  scheduleSuspended = doc["suspend"] | false;
  JsonArray arr = doc["schedules"];  scheduledCount = 0;
  for (JsonObject o : arr) {
    if (scheduledCount >= 4) break;
    Schedule &s = schedules[scheduledCount++];
    s.hour      = o["hour"];  s.minute = o["minute"];
    s.steps     = o["steps"]; s.speed  = o["speed"];
    s.antiSteps = o["antiSteps"] | 0;
    s.antiRatio = o["antiRatio"] | 0.0;
    s.reverse   = o["reverse"]  | false;
    Serial.printf("üìÇ %d) %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                  scheduledCount, s.hour, s.minute, s.steps,
                  s.antiSteps, s.antiRatio, s.reverse);
  }
  f.close();
}

/* ---------- MQTT callback ---------- */
void mqttCallback(char* topic, byte* payload, unsigned len) {
  String msg;  for (unsigned i = 0; i < len; i++) msg += (char)payload[i];

  DynamicJsonDocument doc(1024);
  if (deserializeJson(doc, msg)) {        // texto simples
    if (msg == "feed") runMotorAdvanced(200, 800, false, 0, 0);
    return;
  }

  if (doc["command"] == "feed") {         // dose imediata
    runMotorAdvanced(doc["steps"]   | 200,
                     doc["speed"]   | 800,
                     doc["reverse"] | false,
                     doc["anticlog_steps"] | 0,
                     doc["anticlog_ratio"] | 0.0);
  }

  if (doc.containsKey("suspend")) {       // suspender / retomar
    scheduleSuspended = doc["suspend"];
    Serial.println(scheduleSuspended ? "‚è∏Ô∏è  Suspenso" : "‚ñ∂Ô∏è  Retomado");
    saveAllSchedules();
  }

  if (doc.containsKey("schedules")) {     // novos hor√°rios
    JsonArray arr = doc["schedules"];  scheduledCount = 0;
    for (JsonObject o : arr) {
      if (scheduledCount >= 4) break;
      Schedule &s = schedules[scheduledCount++];
      s.hour      = o["hour"];  s.minute = o["minute"];
      s.steps     = o["steps"]; s.speed  = o["speed"];
      s.antiSteps = o["anticlog_steps"] | 0;
      s.antiRatio = o["anticlog_ratio"] | 0.0;
      s.reverse   = o["reverse"] | false;
      Serial.printf("üóìÔ∏è  %d) %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    scheduledCount, s.hour, s.minute, s.steps,
                    s.antiSteps, s.antiRatio, s.reverse);
    }
    saveAllSchedules();
  }
}

/* ---------- Wi-Fi ---------- */
void connectWiFi() {
  Serial.println("üîå  A ligar Wi-Fi‚Ä¶");
  startBlink();
  WiFiManager wm;  wm.setConnectTimeout(30);  wm.setConfigPortalTimeout(180);
  if (wm.autoConnect("PetFeeder-Setup", "12345678")) {
    stopBlink();
    Serial.printf("‚úÖ  Wi-Fi ligado a %s  IP %s\n",
                  WiFi.SSID().c_str(), WiFi.localIP().toString().c_str());
  } else {
    Serial.println("‚ö†Ô∏è  Portal aberto ‚Äì configura a rede");
  }
}

/* ---------- NTP & MQTT ---------- */
void syncTime() {
  Serial.print("‚è∞  A sincronizar NTP");
  configTime(0, 0, ntp_server);
  setenv("TZ", "WET-0WEST,M3.5.0/1,M10.5.0/2", 1);  tzset();
  while (time(nullptr) < 100000) { delay(500); Serial.print("."); }
  Serial.println(" ok");
}
void connectMQTT() {
  BearSSL::X509List cert(ca_cert);   secureClient.setTrustAnchors(&cert);
  mqtt_client.setServer(mqtt_broker, mqtt_port);
  mqtt_client.setCallback(mqttCallback);
  while (!mqtt_client.connected()) {
    if (mqtt_client.connect(("petfeeder-" + String(ESP.getChipId())).c_str(),
                            mqtt_username, mqtt_password)) {
      Serial.println("‚úÖ  MQTT ligado");
      mqtt_client.subscribe(mqtt_topic);
    } else {
      Serial.printf("‚ùå  Erro MQTT %d\n", mqtt_client.state());
      delay(3000);
    }
  }
}

/* ---------- Setup ---------- */
void setup() {
  Serial.begin(115200);
  pinMode(STEP_PIN, OUTPUT);  pinMode(DIR_PIN, OUTPUT);
  pinMode(EN_PIN, OUTPUT);    digitalWrite(EN_PIN, HIGH);
  pinMode(BTN_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BTN_PIN), tapISR, RISING);

  LittleFS.begin();
  connectWiFi();
  syncTime();
  mqtt_client.setBufferSize(1024);
  connectMQTT();
  loadAllSchedules();

  if (scheduleSuspended)            startBreath();
  else if (WiFi.status() != WL_CONNECTED) startBlink();
  else                                stopBlink();
}

/* ---------- Loop ---------- */
void loop() {
  /* reset tem prioridade */
  if (resetFlag) {
    noInterrupts(); resetFlag = false; interrupts();
    executeReset(); return;
  }

  /* dispensa manual */
   if (digitalRead(BTN_PIN) == HIGH && !manualFeedActive) {   // agora HIGH = dedo presente
    startManualFeed();
  } else if (digitalRead(BTN_PIN) == LOW && manualFeedActive) {
    stopManualFeed();                                        // LOW  = dedo ausente
  }

  /* LED */
  if (scheduleSuspended) {
    if (!ledBreathing) startBreath();
  } else {
    if (WiFi.status() != WL_CONNECTED) {
      if (!ledBlinking) startBlink();
    } else {
      if (ledBlinking)  stopBlink();
      if (ledBreathing) stopBreath();
    }
  }

  /* MQTT */
  if (!mqtt_client.connected()) connectMQTT();
  mqtt_client.loop();

  /* se suspenso, ignora hor√°rios */
  if (scheduleSuspended) return;

  /* verifica rel√≥gio */
  time_t now = time(nullptr);  struct tm* t = localtime(&now);
  for (int i = 0; i < scheduledCount; i++) {
    Schedule &s = schedules[i];
    if (s.hour == t->tm_hour && s.minute == t->tm_min &&
        abs(now - lastTrigger) > 60) {
      Serial.printf("üöÄ  %02d:%02d  %d passos  anti:%d/%.2f  rev:%d\n",
                    s.hour, s.minute, s.steps,
                    s.antiSteps, s.antiRatio, s.reverse);
      runMotorAdvanced(s.steps, s.speed, s.reverse,
                       s.antiSteps, s.antiRatio);
      lastTrigger = now;
    }
  }
}
