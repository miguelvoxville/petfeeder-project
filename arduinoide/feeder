#include <ESP8266WiFi.h>

/* ---- Aumenta o limite do pacote MQTT para 512 bytes ---- */
#define MQTT_MAX_PACKET_SIZE 512     // <-- aqui est√° a altera√ß√£o!
#include <PubSubClient.h>
/* -------------------------------------------------------- */

#include <LittleFS.h>
#include <ArduinoJson.h>
#include <time.h>
#include <BearSSLHelpers.h>

/* ---------- Configura√ß√µes Wi-Fi ---------- */
const char* ssid     = "OsMarotos";
const char* password = "CASA1234@";

/* ---------- Configura√ß√µes MQTT ---------- */
const char* mqtt_broker   = "ha86020d.ala.eu-central-1.emqxsl.com";
const int   mqtt_port     = 8883;
const char* mqtt_topic    = "petfeeder/command";
const char* mqtt_username = "mrhormigo";
const char* mqtt_password = "Hormigo23888";

/* ---------- Configura√ß√µes NTP ---------- */
const char* ntp_server = "pool.ntp.org";

/* ---------- Pinos do A4988 ---------- */
#define STEP_PIN 14
#define DIR_PIN  16
#define EN_PIN   12

/* ---------- Estado ---------- */
bool scheduleSuspended = false;
time_t lastTrigger = 0;

/* ---------- Estrutura de agendamentos ---------- */
struct Schedule {
  int hour   = -1;
  int minute = -1;
  int steps  = 200;
  int speed  = 800;
};

Schedule schedules[4];
int scheduledCount = 0;

/* ---------- Certificado CA (encurtado) ---------- */
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
-----END CERTIFICATE-----
)EOF";

/* ---------- Inst√¢ncias MQTT ---------- */
BearSSL::WiFiClientSecure secureClient;
PubSubClient mqtt_client(secureClient);

/* ---------- Fun√ß√µes ---------- */
void runMotor(int steps, int speed) {
  Serial.printf("üöö Motor: %d passos a %d ¬µs\n", steps, speed);
  digitalWrite(EN_PIN, LOW);
  digitalWrite(DIR_PIN, HIGH);
  for (int i = 0; i < steps; i++) {
    digitalWrite(STEP_PIN, HIGH);
    delayMicroseconds(speed);
    digitalWrite(STEP_PIN, LOW);
    delayMicroseconds(speed);
  }
  digitalWrite(EN_PIN, HIGH);
  Serial.println("‚úÖ Motor terminou");
}

/* ---------- Persist√™ncia ---------- */
void saveAllSchedules() {
  File f = LittleFS.open("/schedules.json", "w");
  if (!f) { Serial.println("‚ùå N√£o consegui guardar!"); return; }

  StaticJsonDocument<512> doc;
  JsonArray arr = doc.createNestedArray("schedules");
  for (int i = 0; i < scheduledCount; i++) {
    JsonObject o = arr.createNestedObject();
    o["hour"]   = schedules[i].hour;
    o["minute"] = schedules[i].minute;
    o["steps"]  = schedules[i].steps;
    o["speed"]  = schedules[i].speed;
  }
  serializeJson(doc, f);
  f.close();
  Serial.println("‚úÖ Agendamentos guardados");
}

void loadAllSchedules() {
  if (!LittleFS.exists("/schedules.json")) { Serial.println("‚ÑπÔ∏è Sem agendamentos"); return; }
  File f = LittleFS.open("/schedules.json", "r");
  if (!f) return;

  StaticJsonDocument<512> doc;
  if (deserializeJson(doc, f)) { Serial.println("‚ùå JSON inv√°lido"); return; }

  JsonArray arr = doc["schedules"];
  scheduledCount = 0;
  for (JsonObject o : arr) {
    if (scheduledCount >= 4) break;
    schedules[scheduledCount].hour   = o["hour"];
    schedules[scheduledCount].minute = o["minute"];
    schedules[scheduledCount].steps  = o["steps"];
    schedules[scheduledCount].speed  = o["speed"];
    Serial.printf("üìÇ Carregado %02d:%02d (%d passos, %d ¬µs)\n",
                  schedules[scheduledCount].hour,
                  schedules[scheduledCount].minute,
                  schedules[scheduledCount].steps,
                  schedules[scheduledCount].speed);
    scheduledCount++;
  }
  f.close();
}

/* ---------- MQTT Callback ---------- */
void mqttCallback(char* topic, byte* payload, unsigned int len) {
  String msg;
  for (unsigned int i = 0; i < len; i++) msg += (char)payload[i];
  msg.trim();
  Serial.print("[MQTT] -> "); Serial.println(msg);

  StaticJsonDocument<512> doc;
  if (deserializeJson(doc, msg)) {
    if (msg == "feed") runMotor(200, 800);
    return;
  }

  /* feed instant√¢neo */
  if (doc["command"] == "feed") {
    runMotor(doc["steps"] | 200, doc["speed"] | 800);
  }

  /* suspender / retomar */
  if (doc["suspend"] == true)  { scheduleSuspended = true;  Serial.println("‚è∏Ô∏è Suspenso"); }
  if (doc["resume"]  == true)  { scheduleSuspended = false; Serial.println("‚ñ∂Ô∏è Retomado"); }

  /* novos agendamentos */
  if (doc.containsKey("schedules")) {
    JsonArray arr = doc["schedules"];
    scheduledCount = 0;
    for (JsonObject o : arr) {
      if (scheduledCount >= 4) break;
      schedules[scheduledCount].hour   = o["hour"];
      schedules[scheduledCount].minute = o["minute"];
      schedules[scheduledCount].steps  = o["steps"];
      schedules[scheduledCount].speed  = o["speed"];
      Serial.printf("üóìÔ∏è Def %d -> %02d:%02d (%d, %d¬µs)\n",
                    scheduledCount+1,
                    schedules[scheduledCount].hour,
                    schedules[scheduledCount].minute,
                    schedules[scheduledCount].steps,
                    schedules[scheduledCount].speed);
      scheduledCount++;
    }
    saveAllSchedules();
  }
}

/* ---------- Conectividade ---------- */
void connectWiFi() {
  WiFi.begin(ssid, password);
  Serial.print("üîå Wi-Fi");
  while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
  Serial.println(" ‚úîÔ∏è");
}

void syncTime() {
  configTime(0, 0, ntp_server);
  setenv("TZ", "WET-0WEST,M3.5.0/1,M10.5.0/2", 1); tzset();
  while (time(nullptr) < 100000) { delay(500); Serial.print("."); }
  Serial.println("\n‚è∞ Hora ok");
}

void connectMQTT() {
  BearSSL::X509List cert(ca_cert);
  secureClient.setTrustAnchors(&cert);
  mqtt_client.setServer(mqtt_broker, mqtt_port);
  mqtt_client.setCallback(mqttCallback);

  while (!mqtt_client.connected()) {
    String cid = "petfeeder-" + String(ESP.getChipId());
    if (mqtt_client.connect(cid.c_str(), mqtt_username, mqtt_password)) {
      Serial.println("‚úÖ MQTT ligado");
      mqtt_client.subscribe(mqtt_topic);
    } else {
      Serial.printf("‚ùå Falha (%d). Retentar...\n", mqtt_client.state());
      delay(3000);
    }
  }
}

/* ---------- Setup ---------- */
void setup() {
  Serial.begin(115200);
  pinMode(STEP_PIN, OUTPUT); pinMode(DIR_PIN, OUTPUT); pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, HIGH);

  LittleFS.begin();
  connectWiFi();
  syncTime();
  connectMQTT();
  loadAllSchedules();
}

/* ---------- Loop ---------- */
void loop() {
  if (!mqtt_client.connected()) connectMQTT();
  mqtt_client.loop();

  if (scheduleSuspended) return;

  time_t now = time(nullptr);
  struct tm* t = localtime(&now);

  for (int i = 0; i < scheduledCount; i++) {
    if (schedules[i].hour == t->tm_hour &&
        schedules[i].minute == t->tm_min &&
        abs(now - lastTrigger) > 60) {
      runMotor(schedules[i].steps, schedules[i].speed);
      lastTrigger = now;
    }
  }
}
